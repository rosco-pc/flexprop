'' automatically generated by fastspin v 3.9.17 on Sat Feb  2 22:22:55 2019
'' command line: /home/ersmith/Parallax/spin2cpp/build/fastspin -w -2 multiply.spin 

con
        __MBOX_SIZE = 6
        __STACK_SIZE = 1
var
  long __mbox[__MBOX_SIZE]   ' mailbox for communicating with remote COG
  long __objmem[0]          ' space for hub data in COG code
  long __stack[__STACK_SIZE] ' stack for new COG
  byte __cognum              ' 1 + the ID of the running COG (0 if nothing running)

'' Code to start the object running in its own COG
'' This must always be called before any other methods
pub __coginit(id)
  if (__cognum == 0) ' if the cog isn't running yet
    __fixup_addresses
    longfill(@__mbox, 0, __MBOX_SIZE)
    __mbox[1] := @entry
    __mbox[2] := @__objmem
    __mbox[3] := @__stack
    if (id < 0)
      id := cognew(@entry, @__mbox)
    else
      coginit(id, @entry, @__mbox) ' actually start the cog
    __cognum := id + 1
  return id

pub __cognew
  return __coginit(-1)

'' Code to stop the remote COG
pub __cogstop
  if __cognum
    __lock  ' wait until everyone else is finished
    cogstop(__cognum~ - 1)
    __mbox[0] := 0
    __cognum := 0

'' Code to lock access to the PASM COG
'' The idea here is that (in theory) multiple Spin bytecode threads might
'' want access to the PASM COG, so this lock mackes sure they don't step on each other.
'' This method also makes sure the remote COG is idle and ready to receive commands.
pri __lock
  repeat
    repeat until __mbox[0] == 0   ' wait until no other Spin code is using remote
    __mbox[0] := __cognum         ' try to claim it
  until __mbox[0] == __cognum     ' make sure we really did get it

  repeat until __mbox[1] == 0     ' now wait for the COG itself to be idle

'' Code to release access to the PASM COG
pri __unlock
  __mbox[0] := 0

'' Check to see if the PASM COG is busy (still working on something)
pub __busy
  return __mbox[1] <> 0

'' Code to send a message to the remote COG asking it to perform a method
'' func is the PASM entrypoint of the method to perform
'' if getresult is nonzero then we wait for the remote COG to answer us with a result
'' if getresult is 0 then we continue without waiting (the remote COG runs in parallel
'' We must always call __lock before this, and set up the parameters starting in __mbox[2]
pri __invoke(func, getresult) : r
  __mbox[1] := func - @entry     ' set the function to perform (NB: this is a HUB address)
  if getresult                   ' if we should wait for an answer
    repeat until __mbox[1] == 0  ' wait for remote COG to be idle
    r := __mbox[2]               ' pick up remote COG result
  __unlock                       ' release to other COGs
  return r

'' Code to convert Spin relative addresses to absolute addresses
'' The PASM code contains some absolute pointers internally; but the
'' regular Spin compiler cannot emit these (bstc and fastspin can, with the
'' @@@ operator, but we don't want to rely on having those compilers).
'' So the compiler inserts a chain of fixups, with each entry having the Spin
'' relative address in the low word, and a pointer to the next fixup in the high word.
'' This code follows that chain and adjusts the relative addresses to absolute ones.
pri __fixup_addresses | ptr, nextptr, temp
  ptr := __fixup_ptr[0]
  repeat while (ptr)      ' the fixup chain is terminated with a 0 pointer
    ptr := @@ptr          ' point to next fixup
    temp := long[ptr]     ' get the data
    nextptr := temp >> 16 ' high 16 bits contains link to next fixup
    temp := temp & $ffff  ' low 16 bits contains real pointer
    long[ptr] := @@temp   ' replace fixup data with real pointer
    ptr := nextptr
  __fixup_ptr[0] := 0 ' mark fixups as done

'--------------------------------------------------
' Stub functions to perform remote calls to the COG
'--------------------------------------------------

pub builtinmul(a, b) : r0, r1, r2
  __lock
  __mbox[2] := a
  __mbox[3] := b
  __mbox[1] := @pasm_builtinmul - @entry
  repeat until __mbox[1] == 0
  r0 := __mbox[2]
  r1 := __mbox[3]
  r2 := __mbox[4]
  __unlock

pub cordicmul(a, b) : r0, r1, r2
  __lock
  __mbox[2] := a
  __mbox[3] := b
  __mbox[1] := @pasm_cordicmul - @entry
  repeat until __mbox[1] == 0
  r0 := __mbox[2]
  r1 := __mbox[3]
  r2 := __mbox[4]
  __unlock

pub hwmul(a, b) : r0, r1, r2
  __lock
  __mbox[2] := a
  __mbox[3] := b
  __mbox[1] := @pasm_hwmul - @entry
  repeat until __mbox[1] == 0
  r0 := __mbox[2]
  r1 := __mbox[3]
  r2 := __mbox[4]
  __unlock

pub swmul(a, b) : r0, r1, r2
  __lock
  __mbox[2] := a
  __mbox[3] := b
  __mbox[1] := @pasm_swmul - @entry
  repeat until __mbox[1] == 0
  r0 := __mbox[2]
  r1 := __mbox[3]
  r2 := __mbox[4]
  __unlock

'--------------------------------------------------
' The converted object (Spin translated to PASM)
' This is the code that will run in the remote COG
'--------------------------------------------------

dat
        cogid   $1d0
        coginit $1d0,##$400
        orgh    $10
        long    160000000 ' clock frequency
        long    $10c3f04 ' clock mode
        orgh    $400
        org     0
entry
        mov     mboxptr, ptra
        add     mboxptr, #8
        rdlong  objptr, mboxptr
        add     mboxptr, #4
        rdlong  ptra, mboxptr
        sub     mboxptr, #8
        wrlong  #0, mboxptr
waitloop
        rdlong  mboxcmd, mboxptr wz
 if_e   jmp     #waitloop
        add     mboxptr, #4
        rdlong  arg01, mboxptr
        add     mboxptr, #4
        rdlong  arg02, mboxptr
        sub     mboxptr, #4
        shr     mboxcmd, #2
        calla   mboxcmd
        wrlong  result1, mboxptr
        add     mboxptr, #4
        wrlong  result2, mboxptr
        add     mboxptr, #4
        wrlong  result3, mboxptr
        sub     mboxptr, #12
        mov     arg01, #0
        wrlong  arg01, mboxptr
        jmp     #waitloop

pasm_builtinmul
_builtinmul
        getct   result1
        mov     _builtinmul_t, result1
        mov     muldiva_, arg01
        mov     muldivb_, arg02
        calla   #multiply_
        getct   result1
        sub     result1, _builtinmul_t
        mov     result3, result1
        mov     result1, muldiva_
        mov     result2, muldivb_
_builtinmul_ret
        reta

pasm_cordicmul
_cordicmul
        getct   result1
        mov     _cordicmul_t, result1
        qmul    arg01, arg02
        getqx   _cordicmul_lo
        getqy   result2
        getct   result1
        sub     result1, _cordicmul_t
        mov     result3, result1
        mov     result1, _cordicmul_lo
_cordicmul_ret
        reta

pasm_hwmul
_hwmul
        getct   result1
        mov     _hwmul_t, result1
        mov     _hwmul_ahi, arg01
        shr     _hwmul_ahi, #16
        mov     _hwmul_bhi, arg02
        shr     _hwmul_bhi, #16
        mov     _hwmul_lo, arg01
        mov     result2, _hwmul_ahi
        mul     _hwmul_lo, arg02
        mul     result2, _hwmul_bhi
        mul     _hwmul_ahi, arg02
        mul     _hwmul_bhi, arg01
        mov     _hwmul_a, _hwmul_ahi
        shl     _hwmul_a, #16
        shr     _hwmul_ahi, #16
        mov     _hwmul_b, _hwmul_bhi
        shl     _hwmul_b, #16
        shr     _hwmul_bhi, #16
        add     _hwmul_lo, _hwmul_a wc
        addx    result2, _hwmul_ahi
        add     _hwmul_lo, _hwmul_b wc
        addx    result2, _hwmul_bhi
        getct   result1
        sub     result1, _hwmul_t
        mov     result3, result1
        mov     result1, _hwmul_lo
_hwmul_ret
        reta

pasm_swmul
_swmul
        getct   result1
        mov     _swmul_t, result1
        mov     _swmul_lo, #0
        mov     _swmul_hi, #0
        mov     _swmul_bhi, #0
        cmp     arg01, #0 wz
 if_e   jmp     #LR__0002
LR__0001
        test    arg01, #1 wz
 if_ne  add     _swmul_lo, arg02 wc
 if_ne  addx    _swmul_hi, _swmul_bhi
        add     arg02, arg02 wc
        addx    _swmul_bhi, _swmul_bhi
        shr     arg01, #1 wz
 if_ne  jmp     #LR__0001
LR__0002
        getct   result1
        sub     result1, _swmul_t
        mov     result3, result1
        mov     result1, _swmul_lo
        mov     result2, _swmul_hi
_swmul_ret
        reta

multiply_
        mov     itmp2_, muldiva_
        xor     itmp2_, muldivb_
        abs     muldiva_, muldiva_
        abs     muldivb_, muldivb_
        qmul    muldiva_, muldivb_
        getqx   muldiva_
        getqy   muldivb_
        shr     itmp2_, #31 wz
 if_nz  neg     muldivb_, muldivb_
 if_nz  neg     muldiva_, muldiva_ wz
 if_nz  sub     muldivb_, #1
        reta

itmp1_
        long    0
itmp2_
        long    0
mboxcmd
        long    0
mboxptr
        long    0
objptr
        long    0
result1
        long    0
result2
        long    0
result3
        long    0
COG_BSS_START
        fit     496
        orgh
        org     COG_BSS_START
_builtinmul_t
        res     1
_cordicmul_lo
        res     1
_cordicmul_t
        res     1
_hwmul_a
        res     1
_hwmul_ahi
        res     1
_hwmul_b
        res     1
_hwmul_bhi
        res     1
_hwmul_lo
        res     1
_hwmul_t
        res     1
_swmul_bhi
        res     1
_swmul_hi
        res     1
_swmul_lo
        res     1
_swmul_t
        res     1
arg01
        res     1
arg02
        res     1
muldiva_
        res     1
muldivb_
        res     1
        fit     496
__fixup_ptr
        long    0
